#ifndef _INTERSECTION_TREE_H_
#define _INTERSECTION_TREE_H_

#include <functional>
#include <list>

#include "rectangle.h"


/**
 * \brief This class is used to calculate all possible intersections of given set of rectangles
 *
 * The idea is to generate tree where each node represents rectangle (either input or intersection)
 * - root node (level 0) is dummy node, its rectangle is not used
 * - child nodes of root node correspond to input rectangles (level 1)
 * - all other nodes represent intersection between rectangle in parent node and some other input rectangle.
 *
 * Each node also contains ID that indicates what input rectangle can be used to generate child nodes.
 * To be sure that there are no duplicates in the tree the following rule is applied:
 * child nodes are generated only using input rectangles with ID >= node ID. Input rectangle ID correspond to the index in input vector.
 *
 * Rectangle of intersection node is generated by intersection of parent's rectangle and input rectangle with index == (node index - 1).
 */
class IntersectionTree {
public:
    using NodeVisitor = std::function<void(const std::vector<unsigned>& ids, const Rectangle& rect)>;

    /**
     * \brief Generates IntersectionTree object from a given vector of rectangles
     */
    static IntersectionTree generate(const std::vector<Rectangle>& rectangles);

    /**
     * \brief Visits every node in a tree using level order traversal.
     */
    void visitInLevelOrder(const NodeVisitor&) const;

private:
    /**
     * \brief This class represents node in a tree.
     */
    class Node {
    public:
        /**
         * \brief Creates dummy root node. Rectangle in this node is not used.
         */
        Node() : id_(0), rect_(Rectangle(0,0,1,1)) {}
        Node(unsigned id, const Rectangle& rect) : id_(id), rect_(rect) {}

        unsigned getId() const {
            return id_;
        }

        bool canCreateChild(const Rectangle& rect) {
            return getId() == 0 || Rectangle::canIntersect(rect_, rect);
        }

        Node& createChild(unsigned id, const Rectangle& rect) {
            children_.push_back(Node(id, generateIntersection(rect)));
            return children_.back();
        }

        unsigned depth() const {
            return children_.size() > 0 ? children_.front().depth() + 1 : 1;
        }

        /**
         * \brief visits all nodes at given depth
         */
        void visitDepth(unsigned depth, std::vector<unsigned>& ids, const NodeVisitor& visitor) const;

    private:
        Rectangle generateIntersection(const Rectangle& rect) const {
            // Node with id == 0 is dummy node. We do not compute intersection
            return (getId() == 0) ? rect : Rectangle::createIntersection(rect_, rect);
        }

        unsigned id_;
        Rectangle rect_;
        std::list<Node> children_;
    };

    IntersectionTree(Node&& root) : root_(root) {}

    const Node root_;
};

#endif // _INTERSECTION_TREE_H_
